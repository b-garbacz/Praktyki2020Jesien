gift_rc =[0x00000001, 0x00000003, 0x00000007, 0x0000000F, 0x0000001F, 0x0000003E, 0x0000003D, 0x0000003B, 0x00000037, 0x0000002F,
    0x0000001E, 0x0000003C, 0x00000039, 0x00000033, 0x00000027, 0x0000000E, 0x0000001D, 0x0000003A, 0x00000035, 0x0000002B,
    0x00000016, 0x0000002C, 0x00000018, 0x00000030, 0x00000021, 0x00000002, 0x00000005, 0x0000000B, 0x00000017, 0x0000002E,
    0x0000001C, 0x00000038, 0x00000031, 0x00000023, 0x00000006, 0x0000000D, 0x0000001B, 0x00000036, 0x0000002D, 0x0000001A]


// wektory testowe
K =[ 0x00,0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F]
P =[ 0x00,0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F]

//Inicjalizacja S
//Przykladowe wywolanie S(P)
S: [16][8] -> [4][32][1]
S s= [S0,S1,S2,S3] 
    where
        sP = split`{128} (join P)
        S0 = reverse(sP @@ [0,4 .. 127])
        S1 = reverse(sP @@ [1,5 .. 127])
        S2 = reverse(sP @@ [2,6 .. 127])
        S3 = reverse(sP @@ [3,7 .. 127])

// Funkcja KS
// Przykladowe wywolanie KS(K)
KS: [16][8] -> [4][32][1]
KS ks = [W0#W1,W2#W3,W4#W5,W6#W7]
    where
        KSmatrix = map (\x -> (head x) # (last x)) (groupBy`{2} (reverse (map reverse K)))
        nsW0 = KSmatrix @ 0 
        W0 = split`{16} nsW0
        nsW1 = KSmatrix @ 1
        W1 = split`{16} nsW1
        nsW2 = KSmatrix @ 2
        W2 = split`{16} nsW2
        nsW3 = KSmatrix @ 3
        W3 = split`{16} nsW3
        nsW4 = KSmatrix @ 4
        W4 = split`{16} nsW4
        nsW5 = KSmatrix @ 5
        W5 = split`{16} nsW5
        nsW6 = KSmatrix @ 6
        W6 = split`{16} nsW6
        nsW7 = KSmatrix @ 7
        W7 = split`{16} nsW7
// Operacja Subcells jako funkcja
// Przykladowe wywolanie - Subcells(S(P))
Subcells:[4][32][1] -> [4][32][1]
Subcells tab = [S000 , S11 , S22 , S333]
    where
        S1 =(tab@1) ^ ((tab@0) && (tab@2))
        S0 = (tab@0) ^ (S1 && (tab@3) )
        S2 = S1 ^ (S0 || (tab@2) )
        S3 = (tab@3) ^ S2
        S11 = S1 ^ S3
        S33= ~S3
        S22 = S2 ^ (S0 && S11)
        BUFFOR_S = S0
        S000= S33
        S333 = BUFFOR_S
//Operacja Permbits(Permutacja) jako funckja
//Przykladowe wywolanie - PermBits(Subcells(S(P)))) (KS(K))
PermBits:[4][32][1] -> [4][32][1]        
PermBits sc = [S0,S1,S2,S3]
    where
        S0 = (sc@0) @@ [28,24 .. 0] # (sc@0) @@ [31,27 .. 3] # (sc@0) @@ [30,26 .. 2] # (sc@0) @@ [29,25 .. 1]
        S1 = (sc@1) @@ [29,25 .. 1] # (sc@1) @@ [28,24 .. 0] # (sc@1) @@ [31,27 .. 3] # (sc@1) @@ [30,26 .. 2]
        S2 = (sc@2) @@ [30,26 .. 2] # (sc@2) @@ [29,25 .. 1] # (sc@2) @@ [28,24 .. 0] # (sc@2) @@ [31,27 .. 3]
        S3 = (sc@3) @@ [31,27 .. 3] # (sc@3) @@ [30,26 .. 2] # (sc@3) @@ [29,25 .. 1] # (sc@3) @@ [28,24 .. 0]
//Operacja Dodania klucza rundy jako funkcja
//przykladowe wywolanie - AddRoundKey (PermBits(Subcells(S(P)))) (KS(K))
AddRoundKey:[4][32][1] -> [4][32][1] -> [4][32][1]   
AddRoundKey pb aKS = [pb@0,ARK_S1,ARK_S2,pb@3]
    where
        ARK_S2 = (pb@3) ^ (take`{16} (aKS@1) # drop`{16} (aKS@1))
        ARK_S1 = (pb@2) ^ (take`{16} (aKS@3) # drop`{16} (aKS@3))
//Dodanie LSFT jako funkcja
//przykladowe wywolanie - AddRoundConstant (AddRoundKey (PermBits(Subcells(S(P)))) (KS(K))) (gift_rc) (0)
AddRoundConstant: [4][32][1] ->[40][32] ->[8] -> [4][32][1]
AddRoundConstant ark grc nr = [ark@0,ark@1,ark@2,SARC_3]
    where
        SARC_3 = (ark@3) ^( (split`{32} 0x80000000) ^ (split`{32}(grc @ nr)))
// Aktualizacja Klucza jako funkcja
//przykladowe uzycie - KSUPDATE (KS(K))
KSUPDATE: [4][32][1] -> [4][32][1]
KSUPDATE ks = [W0#W1,W2#W3,W4#W5,W6#W7]
    where
        BUFFOR_W6 = take`{16} (ks@3)>>>2 
        BUFFOR_W7 = drop`{16} (ks@3)>>>12
        W7 = drop`{16} (ks@2)
        W6 = take`{16} (ks@2)
        W5 = drop`{16} (ks@1)
        W4 = take`{16} (ks@1)
        W3 = drop`{16} (ks@0)
        W2 = take`{16} (ks@0)
        W1 = BUFFOR_W7
        W0 = BUFFOR_W6

//Pierwsza runda
//AddRoundConstant (AddRoundKey (PermBits(Subcells(S(P)))) (KS(K))) (gift_rc) (0)
//KSUPDATE (KS(K))
//Druga runda
//AddRoundConstant (AddRoundKey (PermBits(Subcells(AddRoundConstant (AddRoundKey (PermBits(Subcells(S(P)))) (KS(K))) (gift_rc) (0)))) (KSUPDATE(KS(K)))) (gift_rc) (1)
//KSUPDATE (KSUPDATE (KS(K)))
//Wniosek... Trzeba stworzyć funkcje rekurencyjna.

//Funkcja inkrementująca
increment (x : [8]) = x + 1
//Funkcja t która zamienia S i KS i numer rundy na tuple
t s ks nr =(x,y,z)
    where x =s
    where y= ks
    where z = nr 

// Funkcja inicjalizująca rundę, została zmodyfikowana w ten sposób ze tablice ze stałymi dla LSFR są już zawarte w funkcji 
//Co pozwala na ograniczenie jednego parametru wejściowego co naprawdę ułatwia wywołanie funkcji
//giftround: [4][32][1] -> [4][32][1] ->[8]  ->([4][32][1],[4][32][1])
giftround (s, ks, nr)  =(x,y,nr)
    where   gift_rc =[0x00000001, 0x00000003, 0x00000007, 0x0000000F, 0x0000001F, 0x0000003E, 0x0000003D, 0x0000003B, 0x00000037, 0x0000002F,
    0x0000001E, 0x0000003C, 0x00000039, 0x00000033, 0x00000027, 0x0000000E, 0x0000001D, 0x0000003A, 0x00000035, 0x0000002B,
    0x00000016, 0x0000002C, 0x00000018, 0x00000030, 0x00000021, 0x00000002, 0x00000005, 0x0000000B, 0x00000017, 0x0000002E,
    0x0000001C, 0x00000038, 0x00000031, 0x00000023, 0x00000006, 0x0000000D, 0x0000001B, 0x00000036, 0x0000002D, 0x0000001A]
    where   x = (AddRoundConstant(AddRoundKey(PermBits(Subcells(s))) (ks)) (gift_rc) (nr))
    where   y = (KSUPDATE(ks))
    //        if nr == 0 then  giftround((x) (y) (increment(nr))) else giftround((x) (y) (increment(nr)))

z=giftround (t (S(P)) (KS(K)) (0))
// Funkcja rekurencyjna która wykonuje 40 rund
//rec (giftround(t(S(P)) (KS(K)) (0)))
rec (s, ks, nr) = ns
    where ns = 
                if nr < 38 then rec (giftround(t (s) (ks) (increment(nr))))
                else  giftround(t (s) (ks) (increment(nr)))
//Funkcja która umożliwia powrót S do stanu jak przez zamianą w tuple
returnS (s,ks,nr) = [S0,S1,S2,S3]
    where S0 = s@0
    where S1 = s@1
    where S2 = s@2
    where S3 = s@3
xd= returnS(rec(giftround(t(S(P)) (KS(K)) (0))))

//Funkcja umożliwająca zmianę typu macierzy końcowej na wektor wyjściowy 

Sback [S0,S1,S2,S3]  = [c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15]
    where 
        sP = join([(reverse(S0)),(reverse(S1)),(reverse(S2)),(reverse(S3))])
        c0 = join((sP @@ [0,32 ..96]) # (sP @@ [1,33 ..97]))
        c1 = join((sP @@ [2,34 ..98]) # (sP @@ [3,35 ..99]))
        c2 = join((sP @@ [4,36 ..100]) # (sP @@ [5,37 ..101]))
        c3 = join((sP @@ [6,38 ..102]) # (sP @@ [7,39 ..103]))
        c4 = join((sP @@ [8,40 ..104]) # (sP @@ [9,41 ..105]))
        c5 = join((sP @@ [10,42 ..106]) # (sP @@ [11,43 ..107]))
        c6 = join((sP @@ [12,44 ..108]) # (sP @@ [13,45 ..109]))
        c7 = join((sP @@ [14,46 ..110]) # (sP @@ [15,47 ..111]))
        c8 = join((sP @@ [16,48 ..112]) # (sP @@ [17,49 ..113]))
        c9 = join((sP @@ [18,50 ..114]) # (sP @@ [19,51 ..115]))
        c10 = join((sP @@ [20,52 ..116]) # (sP @@ [21,53 ..117]))
        c11 = join((sP @@ [22,54 ..118]) # (sP @@ [23,55 ..119]))
        c12 = join((sP @@ [24,56 ..120]) # (sP @@ [25,57 ..121]))
        c13 = join((sP @@ [26,58 ..122]) # (sP @@ [27,59 ..123]))
        c14 = join((sP @@ [28,60 ..124]) # (sP @@ [29,61 ..125]))
        c15 = join((sP @@ [30,62 ..126]) # (sP @@ [31,63 ..127])) 
//Funkcja całego algorytmu gift128 
gift128 Plaintext Key Nr = output
    where
        output = Sback(returnS(rec(giftround(t(S(Plaintext)) (KS(Key)) (Nr)))))