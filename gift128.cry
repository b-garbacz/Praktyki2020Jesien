gift_rc =[0x00000001, 0x00000003, 0x00000007, 0x0000000F, 0x0000001F, 0x0000003E, 0x0000003D, 0x0000003B, 0x00000037, 0x0000002F,
    0x0000001E, 0x0000003C, 0x00000039, 0x00000033, 0x00000027, 0x0000000E, 0x0000001D, 0x0000003A, 0x00000035, 0x0000002B,
    0x00000016, 0x0000002C, 0x00000018, 0x00000030, 0x00000021, 0x00000002, 0x00000005, 0x0000000B, 0x00000017, 0x0000002E,
    0x0000001C, 0x00000038, 0x00000031, 0x00000023, 0x00000006, 0x0000000D, 0x0000001B, 0x00000036, 0x0000002D, 0x0000001A]


K =[ 0x00,0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F]
P =[ 0x00,0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F]

//Inicjalizacja S
S = [S0,S1,S2,S3]
    where
    sP = split`{128} (join P)
    S0 = reverse(sP @@ [0,4 .. 127])
    S1 = reverse(sP @@ [1,5 .. 127])
    S2 = reverse(sP @@ [2,6 .. 127])
    S3 = reverse(sP @@ [3,7 .. 127])

KS =  [W0#W1,W2#W3,W4#W5,W6#W7]
    where
        KSmatrix = map (\x -> (head x) # (last x)) (groupBy`{2} (reverse (map reverse K)))
        nsW0 = KSmatrix @ 0 
        W0 = split`{16} nsW0
        nsW1 = KSmatrix @ 1
        W1 = split`{16} nsW1
        nsW2 = KSmatrix @ 2
        W2 = split`{16} nsW2
        nsW3 = KSmatrix @ 3
        W3 = split`{16} nsW3
        nsW4 = KSmatrix @ 4
        W4 = split`{16} nsW4
        nsW5 = KSmatrix @ 5
        W5 = split`{16} nsW5
        nsW6 = KSmatrix @ 6
        W6 = split`{16} nsW6
        nsW7 = KSmatrix @ 7
        W7 = split`{16} nsW7



//------Od tego momentu powinna rozpocząć się  pętla i wykonać 39 razy. 

//Subcells
Subcells = [S0_0_0 , S1_1_1 , S2_2_2 , S3_3_3_3]
    where
        S1_1 = (S@1) ^ ((S@0) && (S@2) )
        S0_0 = (S@0) ^ (S1_1 && (S@3) )
        S2_2 = S1_1 ^ (S0_0 || (S@2) )
        S3_3 = (S@3) ^ S2_2
        S1_1_1 = S1_1 ^ S3_3
        S3_3_3 = ~S3_3
        S2_2_2 = S2_2 ^ (S0_0 && S1_1_1)
        BUFFOR_S = S0_0
        S0_0_0 = S3_3_3
        S3_3_3_3 = BUFFOR_S
//Permutacja S
PermBits = [pb_S0,pb_S1,pb_S2,pb_S3]
    where
        pb_S0 = (Subcells@0) @@ [28,24 .. 0] # (Subcells@0) @@ [31,27 .. 3] # (Subcells@0) @@ [30,26 .. 2] # (Subcells@0) @@ [29,25 .. 1]
        pb_S1 = (Subcells@1) @@ [29,25 .. 1] # (Subcells@1) @@ [28,24 .. 0] # (Subcells@1) @@ [31,27 .. 3] # (Subcells@1) @@ [30,26 .. 2]
        pb_S2 = (Subcells@2) @@ [30,26 .. 2] # (Subcells@2) @@ [29,25 .. 1] # (Subcells@2) @@ [28,24 .. 0] # (Subcells@2) @@ [31,27 .. 3]
        pb_S3 = (Subcells@3) @@ [31,27 .. 3] # (Subcells@3) @@ [30,26 .. 2] # (Subcells@3) @@ [29,25 .. 1] # (Subcells@3) @@ [28,24 .. 0]
//Dodoawanie klucza rundy
AddRoundKey = [PermBits@0,ARK_S1,ARK_S2,PermBits@3]
    where
        ARK_S2 = (PermBits@3) ^ (take`{16} (KS@1) # drop`{16} (KS@1))
        ARK_S1 = (PermBits@2) ^ (take`{16} (KS@3) # drop`{16} (KS@3))
//Dodawanie stałej rundowej
AddRoundConstant  =[PermBits@0,AddRoundKey@1,AddRoundKey@2,SARC_3]
    where
        SARC_3 = (AddRoundKey@3) ^( (split`{32} 0x80000000) ^ (split`{32}(gift_rc @ 0)))


//  KSmatrix UPDATE
KSUPDATE = [u_W0#u_W1,u_W2#u_W3,u_W4#u_W5,u_W6#u_W7]
    where
        BUFFOR_W6 = take`{16} (KS@3)>>>2 
        BUFFOR_W7 = drop`{16} (KS@3)>>>12
        u_W7 = drop`{16} (KS@2)
        u_W6 = take`{16} (KS@2)
        u_W5 = drop`{16} (KS@1)
        u_W4 = take`{16} (KS@1)
        u_W3 = drop`{16} (KS@0)
        u_W2 = take`{16} (KS@0)
        u_W1 = BUFFOR_W7
        u_W0 = BUFFOR_W6
        







/*
// Tu się ma kończyć pętla
//15 wrzesień- Miałem problem z uporządkowaniem kodu i inicjalizacją funkcji 40 rund. Wieczorem wpadłem na pomysł aby każdą operację
// taką jak subcells, permbits itp... załadować w funkcję. Mimo straconego czasu  zreformowałem kod gdzie każda operacja jest funkcją. 
// Ułatwi mi to utworzenie funkcji rekurencyjnej(Bądź rekursynej.) aby wykonać ten sam kod 39 razy. Ponieważ nie da się nadpisywać zmiennych 
//  jak w imperatywnych językach programowania, po prostu wszystko co dotychczas napisałem musi zostać wielokrotnie powtórzone. 
// 16 września planowana jest zakończenie tego etapu algorytmu. Aby za pomocą funkcji GIFT128 P K = [C0.....C15] osiągnąć ctxt po 40 rundach.
// Wiemy przecież że kod wykonuje się od dołu do góry , to nadpisywanie 40 krotnie wszystkich operacji jest zbędne. Zamieszczenie owej funkcji 
// GIFT128 która jest naszym celem może rozpocząć inicjację od samego dołu. Więc Ten schemat myślenia pozwoli na rozwiazanie dzisiejszego problemu.
//Od teraz wszystko w programie jest funkcją, nie ma niepotrzebnych zmiennych które trzeba było by nadpisywać w sposób IMPERATYWNY.
// TODO:
// Rozpoczęcie funkci gdzie wchodzącymi parametrami jest K, P i Wychodzącym CTXT
// Inicjalizacja pętli dla 40 rund
*/


